name: ðŸ“¡ Collect IP Addresses and Save to Files

on:
  schedule:
    - cron: '30 * * * *'
  workflow_dispatch:
    inputs:
      reason:
        description: 'Reason for manual trigger'
        required: false
        default: 'Manual execution'

env:
  FILES_TO_UPDATE: 'ip.txt ipv6.txt'

permissions:
  contents: write

jobs:
  collect-ip-addresses:
    name: ðŸŽ¯ Collect IP Addresses
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    steps:
      # Step 1: Checkout repository
      - name: ðŸ“¥ Checkout Repository
        uses: actions/checkout@v4

      # Step 2: Set up Python environment
      - name: ðŸ Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      # Step 3: Create and run IP collection script
      - name: ðŸš€ Run IP Collection Script
        run: |
          cat > autoip6.py << 'EOF'
#!/usr/bin/env python3
"""
IP Address Collection Script
Collects IPv4 and IPv6 addresses from various sources
"""

import requests
import re
import json
from datetime import datetime
import sys

def get_public_ipv4():
    """Get public IPv4 address"""
    try:
        response = requests.get('https://api.ipify.org?format=json', timeout=10)
        if response.status_code == 200:
            return response.json()['ip']
    except Exception as e:
        print(f"âŒ Failed to get IPv4: {e}")
    return None

def get_public_ipv6():
    """Get public IPv6 address"""
    try:
        response = requests.get('https://api64.ipify.org?format=json', timeout=10)
        if response.status_code == 200:
            ip = response.json()['ip']
            # Check if it's actually IPv6
            if ':' in ip:
                return ip
    except Exception as e:
        print(f"âŒ Failed to get IPv6: {e}")
    return None

def get_cloudflare_ips():
    """Get Cloudflare IP ranges"""
    try:
        response = requests.get('https://api.cloudflare.com/client/v4/ips', timeout=10)
        if response.status_code == 200:
            data = response.json()
            return {
                'ipv4_cidrs': data['result']['ipv4_cidrs'],
                'ipv6_cidrs': data['result']['ipv6_cidrs']
            }
    except Exception as e:
        print(f"âŒ Failed to get Cloudflare IPs: {e}")
    return None

def validate_ip(ip):
    """Simple IP validation"""
    ipv4_pattern = r'^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$'
    ipv6_pattern = r'^[0-9a-fA-F:]+$'
    
    if re.match(ipv4_pattern, ip):
        parts = ip.split('.')
        if all(0 <= int(part) <= 255 for part in parts):
            return 'ipv4'
    elif re.match(ipv6_pattern, ip) and ':' in ip:
        return 'ipv6'
    return None

def main():
    print("ðŸš€ Starting IP address collection...")
    
    # Collect IPs
    ipv4 = get_public_ipv4()
    ipv6 = get_public_ipv6()
    cloudflare_ips = get_cloudflare_ips()
    
    # Prepare data for files
    ipv4_list = []
    ipv6_list = []
    
    # Add public IPs
    if ipv4:
        ipv4_list.append(ipv4)
        print(f"âœ… Found IPv4: {ipv4}")
    
    if ipv6:
        ipv6_list.append(ipv6)
        print(f"âœ… Found IPv6: {ipv6}")
    
    # Add Cloudflare IPs if available
    if cloudflare_ips:
        ipv4_list.extend(cloudflare_ips['ipv4_cidrs'])
        ipv6_list.extend(cloudflare_ips['ipv6_cidrs'])
        print(f"âœ… Added {len(cloudflare_ips['ipv4_cidrs'])} Cloudflare IPv4 ranges")
        print(f"âœ… Added {len(cloudflare_ips['ipv6_cidrs'])} Cloudflare IPv6 ranges")
    
    # Add some common IPs as fallback
    if not ipv4_list:
        ipv4_list.extend(['8.8.8.8', '1.1.1.1', '9.9.9.9'])
        print("âš ï¸ Using fallback IPv4 addresses")
    
    if not ipv6_list:
        ipv6_list.extend(['2001:4860:4860::8888', '2606:4700:4700::1111', '2620:fe::fe'])
        print("âš ï¸ Using fallback IPv6 addresses")
    
    # Write to files
    try:
        with open('ip.txt', 'w') as f:
            f.write(f"# IPv4 Address Collection\n")
            f.write(f"# Generated at: {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S UTC')}\n")
            f.write(f"# Total IPv4 addresses: {len(ipv4_list)}\n\n")
            for ip in ipv4_list:
                f.write(f"{ip}\n")
        
        with open('ipv6.txt', 'w') as f:
            f.write(f"# IPv6 Address Collection\n")
            f.write(f"# Generated at: {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S UTC')}\n")
            f.write(f"# Total IPv6 addresses: {len(ipv6_list)}\n\n")
            for ip in ipv6_list:
                f.write(f"{ip}\n")
        
        print(f"âœ… Successfully wrote {len(ipv4_list)} IPv4 addresses to ip.txt")
        print(f"âœ… Successfully wrote {len(ipv6_list)} IPv6 addresses to ipv6.txt")
        print("ðŸŽ‰ IP collection completed successfully!")
        
    except Exception as e:
        print(f"âŒ Failed to write files: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
EOF

          # Run the script
          python autoip6.py

      # Step 4: Verify generated files
      - name: ðŸ” Verify Generated Files
        run: |
          echo "ðŸ“‹ Checking generated files:"
          ls -la ip.txt ipv6.txt 2>/dev/null || echo "âš ï¸ Files not found yet"
          echo "--- ip.txt content sample ---"
          head -5 ip.txt 2>/dev/null || echo "File not found"
          echo "--- ipv6.txt content sample ---"
          head -5 ipv6.txt 2>/dev/null || echo "File not found"

      # Step 5: Commit and push changes
      - name: ðŸ’¾ Commit and Push Results
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "chore: update IP address files [auto]"
          commit_user_name: "GitHub Actions"
          commit_user_email: "actions@users.noreply.github.com"
          file_pattern: "ip.txt ipv6.txt"
