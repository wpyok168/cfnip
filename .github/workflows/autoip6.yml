name: ğŸŒ Collect IP Addresses with Regional Filtering

on:
  schedule:
    - cron: '30 * * * *'   # Run at minute 30 of every hour (UTC)
  workflow_dispatch:        # Allow manual triggering
    inputs:
      reason:
        description: 'Reason for manual trigger'
        required: false
        default: 'Manual execution'

env:
  PYTHON_VERSION: '3.x'
  RETAIN_DAYS: 0
  KEEP_MINIMUM_RUNS: 5
  OUTPUT_DIR: 'non-us-ips'

permissions:
  contents: write
  actions: write

jobs:
  collect-ip-addresses:
    name: ğŸš€ Collect IP Addresses
    runs-on: ubuntu-latest
    outputs:
      timestamp: ${{ steps.timestamp.outputs.time }}
      files_changed: ${{ steps.changes-check.outputs.has_changes }}
      output_files: ${{ steps.file-check.outputs.output_files }}
    
    steps:
      # ========== INITIALIZATION ==========
      - name: â° Start Workflow
        run: |
          echo "ğŸ¯ Workflow triggered by: ${{ github.event_name }}"
          echo "ğŸ“… Current time: $(date)"
          echo "ğŸ” Repository: ${{ github.repository }}"
          echo "ğŸŒ¿ Branch: ${{ github.ref }}"
          echo "ğŸ“ Output directory: ${{ env.OUTPUT_DIR }}"

      - name: ğŸ“ Generate Timestamp
        id: timestamp
        run: |
          current_time=$(date -u +'%Y-%m-%d_%H-%M-%S_UTC')
          echo "time=$(date -u +'%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_OUTPUT
          echo "filename_time=$current_time" >> $GITHUB_OUTPUT

      # ========== CLEANUP ==========
      - name: ğŸ§¹ Cleanup Old Workflow Runs
        uses: Mattraks/delete-workflow-runs@v2
        with:
          retain_days: ${{ env.RETAIN_DAYS }}
          keep_minimum_runs: ${{ env.KEEP_MINIMUM_RUNS }}
          repository: ${{ github.repository }}

      # ========== REPOSITORY SETUP ==========
      - name: ğŸ“¥ Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          token: ${{ secrets.GITHUB_TOKEN }}

      # ========== CREATE OUTPUT DIRECTORY ==========
      - name: ğŸ“ Create Output Directory
        run: |
          echo "ğŸ“‚ Creating output directory: ${{ env.OUTPUT_DIR }}"
          mkdir -p ${{ env.OUTPUT_DIR }}
          echo "âœ… Directory created successfully"

      # ========== PYTHON ENVIRONMENT ==========
      - name: ğŸ Set up Python ${{ env.PYTHON_VERSION }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: ğŸ“¦ Install Dependencies
        run: |
          echo "ğŸ”§ Installing Python dependencies..."
          pip install --upgrade pip
          pip install requests ipaddress pycountry
          echo "âœ… Dependencies installed successfully"

      # ========== IP COLLECTION WITH REGIONAL FILTER ==========
      - name: ğŸŒ Collect Non-US IP Addresses
        id: ip-collection
        run: |
          echo "ğŸ•¸ï¸ Starting non-US IP address collection..."
          start_time=$(date +%s)
          
          # åˆ›å»ºå¢å¼ºç‰ˆçš„ IP æ”¶é›†è„šæœ¬
          cat > collect_non_us_ips.py << 'EOF'
import requests
import ipaddress
import json
from datetime import datetime
import os
import time

class NonUSIPCollector:
    def __init__(self):
        self.output_dir = 'non-us-ips'
        self.timestamp = datetime.utcnow().strftime('%Y-%m-%d_%H-%M-%S_UTC')
        
    def is_non_us_ip(self, ip):
        """æ£€æŸ¥ IP æ˜¯å¦ä¸å±äºç¾å›½"""
        try:
            response = requests.get(
                f'http://ip-api.com/json/{ip}?fields=countryCode,status', 
                timeout=5
            )
            if response.status_code == 200:
                data = response.json()
                if data.get('status') == 'success':
                    return data.get('countryCode') != 'US'
            time.sleep(0.1)
        except Exception as e:
            print(f"Error checking IP {ip}: {e}")
        return False
    
    def get_ip_sources(self):
        """è¿”å› IP åœ°å€æ¥æºåˆ—è¡¨"""
        return [
            'https://www.cloudflare.com/ips-v4',
            'https://www.cloudflare.com/ips-v6',
        ]
    
    def collect_ips_from_source(self, url):
        """ä»å•ä¸ªæ¥æºæ”¶é›† IP"""
        try:
            response = requests.get(url, timeout=10)
            if response.status_code == 200:
                return [line.strip() for line in response.text.splitlines() 
                       if line.strip() and not line.startswith('#')]
        except Exception as e:
            print(f"Error fetching from {url}: {e}")
        return []
    
    def filter_non_us_ips(self, ip_list, ip_type="IPv4"):
        """è¿‡æ»¤éç¾å›½ IP"""
        if not ip_list:
            return []
            
        non_us_ips = []
        sample_size = min(3, len(ip_list))
        
        print(f"ğŸ” Checking {sample_size} {ip_type} samples for US location...")
        
        for ip in ip_list[:sample_size]:
            test_ip = ip.split('/')[0] if '/' in ip else ip
            if self.is_non_us_ip(test_ip):
                print(f"   âœ… {test_ip} is non-US, including all IPs from this source")
                return ip_list
            else:
                print(f"   âŒ {test_ip} is US, skipping this source")
                break
                
        return []
    
    def save_files(self, ipv4_list, ipv6_list):
        """ä¿å­˜æ–‡ä»¶åˆ°ç›¸åº”ç›®å½•"""
        os.makedirs(self.output_dir, exist_ok=True)
        
        # ä¸»æ–‡ä»¶
        with open('ip.txt', 'w') as f:
            f.write('\n'.join(ipv4_list))
        
        with open('ipv6.txt', 'w') as f:
            f.write('\n'.join(ipv6_list))
        
        # æ—¶é—´æˆ³æ–‡ä»¶
        ipv4_filename = f'{self.output_dir}/ipv4_non_us_{self.timestamp}.txt'
        ipv6_filename = f'{self.output_dir}/ipv6_non_us_{self.timestamp}.txt'
        
        with open(ipv4_filename, 'w') as f:
            f.write(f'# Non-US IPv4 addresses\n')
            f.write(f'# Collected: {self.timestamp}\n')
            f.write(f'# Total: {len(ipv4_list)} addresses\n\n')
            f.write('\n'.join(ipv4_list))
        
        with open(ipv6_filename, 'w') as f:
            f.write(f'# Non-US IPv6 addresses\n')
            f.write(f'# Collected: {self.timestamp}\n')
            f.write(f'# Total: {len(ipv6_list)} addresses\n\n')
            f.write('\n'.join(ipv6_list))
        
        # å…ƒæ•°æ®
        metadata = {
            'collection_time': self.timestamp,
            'ipv4_count': len(ipv4_list),
            'ipv6_count': len(ipv6_list),
            'output_directory': self.output_dir
        }
        
        with open(f'{self.output_dir}/metadata_{self.timestamp}.json', 'w') as f:
            json.dump(metadata, f, indent=2)
        
        return ipv4_filename, ipv6_filename
    
    def run(self):
        """ä¸»æ‰§è¡Œå‡½æ•°"""
        print(f"ğŸš€ Starting non-US IP collection at {self.timestamp}")
        
        ipv4_list = []
        ipv6_list = []
        
        for source in self.get_ip_sources():
            print(f"ğŸ“¡ Fetching from: {source}")
            ips = self.collect_ips_from_source(source)
            
            for ip in ips:
                try:
                    network = ipaddress.ip_network(ip, strict=False)
                    if network.version == 4:
                        ipv4_list.append(ip)
                    else:
                        ipv6_list.append(ip)
                except:
                    continue
        
        # è¿‡æ»¤éç¾å›½ IP
        print("ğŸ” Filtering non-US IP addresses...")
        filtered_ipv4 = self.filter_non_us_ips(ipv4_list, "IPv4")
        filtered_ipv6 = self.filter_non_us_ips(ipv6_list, "IPv6")
        
        # ä¿å­˜æ–‡ä»¶
        ipv4_file, ipv6_file = self.save_files(filtered_ipv4, filtered_ipv6)
        
        print(f"âœ… Collection completed!")
        print(f"ğŸ“Š IPv4 addresses: {len(filtered_ipv4)}")
        print(f"ğŸ“Š IPv6 addresses: {len(filtered_ipv6)}")
        print(f"ğŸ“ Files saved:")
        print(f"   - {ipv4_file}")
        print(f"   - {ipv6_file}")
        print(f"   - {self.output_dir}/metadata_{self.timestamp}.json")

if __name__ == '__main__':
    collector = NonUSIPCollector()
    collector.run()
EOF

          if python collect_non_us_ips.py; then
            end_time=$(date +%s)
            duration=$((end_time - start_time))
            echo "âœ… Non-US IP collection completed successfully"
            echo "â±ï¸ Execution time: ${duration} seconds"
            echo "result=success" >> $GITHUB_OUTPUT
          else
            echo "âŒ IP collection failed"
            echo "result=failure" >> $GITHUB_OUTPUT
            exit 1
          fi

      # ========== FILE VERIFICATION ==========
      - name: ğŸ” Verify Generated Files
        id: file-check
        run: |
          echo "ğŸ“‹ Checking generated files..."
          
          # æ£€æŸ¥ä¸»æ–‡ä»¶
          if [ -f "ip.txt" ]; then
            ip_count=$(wc -l < ip.txt | tr -d ' ')
            echo "âœ… ip.txt: $ip_count IPv4 addresses"
            echo "ip_count=$ip_count" >> $GITHUB_OUTPUT
          else
            echo "âš ï¸ ip.txt is missing"
            echo "ip_count=0" >> $GITHUB_OUTPUT
          fi
          
          if [ -f "ipv6.txt" ]; then
            ipv6_count=$(wc -l < ipv6.txt | tr -d ' ')
            echo "âœ… ipv6.txt: $ipv6_count IPv6 addresses"
            echo "ipv6_count=$ipv6_count" >> $GITHUB_OUTPUT
          else
            echo "âš ï¸ ipv6.txt is missing"
            echo "ipv6_count=0" >> $GITHUB_OUTPUT
          fi
          
          # æ£€æŸ¥æ—¶é—´æˆ³æ–‡ä»¶
          timestamp="${{ steps.timestamp.outputs.filename_time }}"
          output_dir="${{ env.OUTPUT_DIR }}"
          
          ipv4_file="${output_dir}/ipv4_non_us_${timestamp}.txt"
          ipv6_file="${output_dir}/ipv6_non_us_${timestamp}.txt"
          metadata_file="${output_dir}/metadata_${timestamp}.json"
          
          if [ -f "$ipv4_file" ] && [ -f "$ipv6_file" ]; then
            echo "âœ… Time-stamped files created successfully"
            echo "output_files=true" >> $GITHUB_OUTPUT
          else
            echo "âš ï¸ Some time-stamped files are missing"
            echo "output_files=false" >> $GITHUB_OUTPUT
          fi

      # ========== LIST GENERATED FILES ==========
      - name: ğŸ“‚ List Generated Files
        run: |
          echo "ğŸ“ Generated files in ${{ env.OUTPUT_DIR }}:"
          ls -la ${{ env.OUTPUT_DIR }}/ || echo "No files in directory"
          echo ""
          echo "ğŸ“Š File sizes:"
          find ${{ env.OUTPUT_DIR }} -name "*.txt" -exec wc -l {} \; 2>/dev/null || echo "No text files found"

      # ========== CHANGES CHECK ==========
      - name: ğŸ“Š Check for Changes
        id: changes-check
        run: |
          echo "ğŸ“Š Checking for file changes..."
          if git diff --quiet HEAD -- ip.txt ipv6.txt ${{ env.OUTPUT_DIR }}; then
            echo "ğŸ“­ No changes detected in IP files"
            echo "has_changes=false" >> $GITHUB_OUTPUT
          else
            echo "ğŸ“¬ Changes detected in IP files"
            echo "has_changes=true" >> $GITHUB_OUTPUT
            echo "ğŸ“ Changed files:"
            git diff --name-only HEAD -- ip.txt ipv6.txt ${{ env.OUTPUT_DIR }}
          fi

      # ========== COMMIT CHANGES ==========
      - name: ğŸ’¾ Commit and Push Changes
        id: auto-commit
        if: steps.changes-check.outputs.has_changes == 'true'
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "chore: update non-US IP addresses [auto]"
          commit_user_name: 'GitHub Actions Bot'
          commit_user_email: 'actions@users.noreply.github.com'
          file_pattern: 'ip.txt ipv6.txt ${{ env.OUTPUT_DIR }}/*'
          skip_fetch: true
          skip_checkout: true

      # ========== WORKFLOW SUMMARY ==========
      - name: ğŸ“ˆ Workflow Summary
        if: always()
        run: |
          echo "## ğŸ¯ Non-US IP Collection Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸ“Š Execution Details" >> $GITHUB_STEP_SUMMARY
          echo "- **Triggered by:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Execution time:** ${{ steps.timestamp.outputs.time }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Repository:** ${{ github.repository }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Output directory:** ${{ env.OUTPUT_DIR }}/" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "### ğŸ“ File Status" >> $GITHUB_STEP_SUMMARY
          echo "- **IPv4 addresses:** ${{ steps.file-check.outputs.ip_count }}" >> $GITHUB_STEP_SUMMARY
          echo "- **IPv6 addresses:** ${{ steps.file-check.outputs.ipv6_count }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Time-stamped files:** ${{ steps.file-check.outputs.output_files }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if steps.changes-check.outputs.has_changes == 'true'; then
            echo "### âœ… Changes Committed" >> $GITHUB_STEP_SUMMARY
            echo "IP address files have been updated and committed automatically." >> $GITHUB_STEP_SUMMARY
          else
            echo "### ğŸ“­ No Changes" >> $GITHUB_STEP_SUMMARY
            echo "IP address files are already up to date." >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "*Automatically generated by GitHub Actions*" >> $GITHUB_STEP_SUMMARY

      # ========== NOTIFICATION ==========
      - name: ğŸ‰ Success Notification
        if: success()
        run: |
          echo "ğŸ‰ Workflow completed successfully!"
          echo "ğŸ“Š IPv4 addresses collected: ${{ steps.file-check.outputs.ip_count }}"
          echo "ğŸ“Š IPv6 addresses collected: ${{ steps.file-check.outputs.ipv6_count }}"
